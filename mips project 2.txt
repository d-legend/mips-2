

.data

string_NaN: .asciiz "NaN"
string_tooLarge: .asciiz "too large"
string_comma: .asciiz ","

buff: .space 1001 # space for input string
array: .space 8    #8 element integer array for storing individually converted hex characters

.text

.globl main
#s0 is for number of characters counted
#s1 is for the address of the array
#s2 is set to -1 if a valid character is seen
#s3 is set to 1 if a space is seen after a character
#s4 is for
#s5 is for
#s6 is for integer storage
#s7 is set to 1 for NaN
#a2 is set to character dec euivalent
main:

	la $a0,buff# input string address
	li $a1,1001 
	li $v0,8 #read string
	syscall
	
	functions:
		li $s2,0
		jal subprogram2

		jal subprogram3 




#
#Changes each charater into its decimal equivalent
#
subprogram_1:

	ZeroToNine:
		move $t2, $zero

		li $t6,47
		li $t7,58
		slt $t0,$t6,$t4    # Sets $t0=1 if $t6 < $t4, otherwise $t0=0
		slt $t1,$t4,$t7    # Sets $t1=1 if $t4 < $t7, otherwise $t1=0
		and  $t2, $t1, $t0    # Sets $t2=1 if $t6 < $t4 < $t7, otherwise $t0=0
		beq $t2, 0, A_To_F
		add $s0, $0, 1  
		add $a2, $t4, -48 
		$s0

	A_To_F:
		li $t6,64
		li $t7,71
		slt $t0,$t6,$t4    # Sets $t0=1 if $t6 < $t4, otherwise $t0=0
		slt $t1,$t4,$t7    # Sets $t1=1 if $t4 < $t7, otherwise $t1=0
		and  $t3, $t1, $t0    # Sets $t3=1 if $t6 < $t4 < $t7, otherwise 				#$t0=0
		beq $t3, 0, a_to_f
		add $s0, $s0, 1  
		add $a2, $t4, -55  


	a_to_f:
		or $t2, $t2, $t3    
		li $t6,96
		li $t7,103
		slt $t0,$t6,$t4    # Sets $t0=1 if $t6 < $t4, otherwise $t0=0
		slt $t1,$t4,$t7    # Sets $t1=1 if $t4 < $t7, otherwise $t1=0	
		and  $t0, $t1, $t0    # Sets $t0=1 if $t6 < $t4 < $t7, otherwise $t0=0
		beq $t0, 0, OtherCharacters
		add $s0, $s0, 1 
		add $a2, $t4, -87
	
	li $s2, -1
	beq $s3, 1, set_s7_1
	j continue		#jump to continue label

	OtherCharacters:
		bne $t4, 32, Else #j if it is not a space
		slti $s3, $s2, 0
		j continue
		
			Else:
				bne $t4, 10, Else2 #j if not return char
				j calc_dec	
			Else2:
				bne $t4, 44, Else3 #j if not comma char
				j calc_dec	
			Else3:
				bne $t4, 0, set_s7_1 #j if not null char
				j calc_dec	


subprogram_2:
	move $s0, $zero
	la $s1, array	# load the address of the array into $s1
	jal subprogram_1
	
	continue:
		add $a0, $a0, 1   #increment address of input string
		beq $s0,9, tooLarge

		
		#lb $s2, 0($s1)           # load a byte from the array into $a2
		sb $a2, 0($s1)           # store the new value into memory
		addi $s1, $s1, 1         # increment $s1 by one, to point to the next element in the array
		
	calc_dec:
		li $t7, 16
		la $s1, array	#put array to s1
		beq $s7, 1, Not_a_num
		beq $s0, 0, functions
#if array counter =0 then move to next hex segment
#load byte from array
		lb $t1, 0($s1)           # load a byte from the array into $t1
		
		hex_power:
			beq $s0, 0, int_add 
			addi $t5, $t5, 1
			addi $s0, $s0, -1
			move $t8, $s0	#copy int count to t8 for use in finding power
			pow:
  				li    $t0, 1
  				li    $t1, 0
			pow_loop:
  				blez   $t8, hex_power
  				mult  $t1, $t7
  				mflo  $t1
 		 		mult  $t0, $t7
  				mflo  $t0
  				mfhi  $t2
  				add   $t1, $t1, $t2
  				addi  $t8, $t8, -1
  				j     pow_loop
\
  				
			bne $s0, $t5, hex_power	#b if power not equal to the number of characters
				
		
			mul $t1, 
			addi $s1, $s1, 1         # increment $s1 by one, to point to the next element in the array
		
		int_add:
			add $s6, s6, $t1
				
				
#multiply that by 16 to the power of the number of $s0 -1  
#-1 from $s0
#


#if string is a valid string branch to sub program 1
#
#It converts a single hexadecimal string to a decimal integer. 
#It must call Subprogram 1 to get the decimal value of each of the characters in the string. 
#Registers must be used to pass parameters into the subprogram. Values must be returned via the stack.
	set_s7_1:
		li $s7,1
	j continue
	
			
subprogram_3:
	
	la $a0,stack #load from stack into argument for integer output
	li $v0,1	#print integer
	syscall
	li $v0, 10	#exit
	syscall
	j functions
#displays unsigned decimal integer stack is used to pass parameters into subprogram

tooLarge:
	la $a0, string_tooLarge 
	li $v0,4	#print too large
	syscall
	j functions

Not_a_num:
	la $a0, string_NaN 
	li $v0,4	#print NaN
	syscall
	j functions

Comma:
	la $a0, string_comma 
	li $v0,4	#print NaN
	syscall
	j functions
