#s0 is for number of characters counted
#s1 is for the address of the array
#s2 is set to -1 if a valid character is seen
#s3 is set to 1 if a space is seen after a character
#s4 is set to 1 if a comma is needed in output
#s5 is for integer storage lo
#s6 is for integer storage hi
#s7 is set to 1 for NaN
#a2 is set to character dec equivalent

.data

string_NaN: .asciiz "NaN"
string_tooLarge: .asciiz "too large"
string_comma: .asciiz ","

buff: .space 8 # space for input string
array: .space 8    #8 element integer array for storing individually converted hex characters

.text

.globl main

main:

	la $a0,buff# input string address
	li $a1,8 
	li $v0,8 #read string
	syscall
	xor $a0, $a0, $a0
	functions:
		li $s2,0
		jal subprogram_2
		
		bne $s4, 1, Else0
				la $a0, string_comma 
				li $v0,4	#print NaN
				syscall
		Else0:	
		jal subprogram_3 




#
#Changes each charater into its decimal equivalent
#
subprogram_1:

	ZeroToNine:
		move $t2, $zero

		li $t6,47
		li $t7,58
		slt $t0,$t6,$t4    # Sets $t0=1 if $t6 < $t4, otherwise $t0=0
		slt $t1,$t4,$t7    # Sets $t1=1 if $t4 < $t7, otherwise $t1=0
		and  $t2, $t1, $t0    # Sets $t2=1 if $t6 < $t4 < $t7, otherwise $t0=0
		beq $t2, 0, A_To_F
		add $s0, $s0, 1  
		add $a2, $t4, -48 
		

	A_To_F:
		li $t6,64
		li $t7,71
		slt $t0,$t6,$t4    # Sets $t0=1 if $t6 < $t4, otherwise $t0=0
		slt $t1,$t4,$t7    # Sets $t1=1 if $t4 < $t7, otherwise $t1=0
		and  $t3, $t1, $t0    # Sets $t3=1 if $t6 < $t4 < $t7, otherwise 				#$t0=0
		beq $t3, 0, a_to_f
		add $s0, $s0, 1  
		add $a2, $t4, -55  


	a_to_f:
		or $t2, $t2, $t3    
		li $t6,96
		li $t7,103
		slt $t0,$t6,$t4    # Sets $t0=1 if $t6 < $t4, otherwise $t0=0
		slt $t1,$t4,$t7    # Sets $t1=1 if $t4 < $t7, otherwise $t1=0	
		and  $t0, $t1, $t0    # Sets $t0=1 if $t6 < $t4 < $t7, otherwise $t0=0
		or $t2, $t2, $t0 
		beq $t2, 0, OtherCharacters
		beq $t0, 0, moveOn_0
		add $s0, $s0, 1 
		add $a2, $t4, -87
	
	moveOn_0:
		li $s2, -1
		beq $s3, 1, set_s7_1
	j continue		#jump to continue label

	OtherCharacters:
		   
		bne $t4, 32, E1 #j if it is not a space
		E1:
			bne $t4, 9, Else #j if not tab char

		slti $s3, $s2, 0		#if set s3 1 if you see a charrater and then a space
		bne $s2,-1, NoChar	#j to NoChar if s2 is no char yet
		j end
		NoChar:
		li $t6,1		#set t6 1 if no char is seen yet
		end:
		j continue
		
			Else:
				bne $t4, 10, Else2 #j if not return char
				j calc_dec	
			Else2:
				bne $t4, 44, Else3 #j if not comma char
				li $s4, 1
				beq $t6, 1, set_s7_1 #j if all spaces and then comma
				j calc_dec	
			Else3:
				bne $t4, 0, set_s7_1 #j if not null char
				j calc_dec	


subprogram_2:
	lbu $t4, buff($a0)   #loading each byte of input string
	move $s0, $zero
	la $s1, array	# load the address of the array into $s1
	j subprogram_1
	
	continue:
		add $a0, $a0, 1   #increment address of input string
		lbu $t4, buff($a0)
		sb $a2, 0($s1)           # store the new value into memory
		addi $s1, $s1, 1         # increment $s1 by one, to point to the next element in the array
		j subprogram_1		#keep going until either null, return or comma seen
		
	calc_dec:			#calculate decimal
		beq $s0,9, tooLarge
		beq $s7, 1, Not_a_num
		beq $s0, 0, functions	#if array counter =0 then move to next hex segment
		li $t7, 16		#the base that we will raise to a power
		la $s1, array	#put array to s1
		lb $t9, 0($s1)           # load a byte from the array into $t1
		
		hex_power:
			beq $s0, 1, int_add 	#b if count is 1 and add value to lower 32 bit
			addi $s0, $s0, -1
			move $t8, $s0	#copy int count to t8 for use in finding power
			
			pow:
  				li    $t0, 1
  				li    $t1, 0
			pow_loop:
  				blez   $t8, dec_x_pow16
  				multu  $t1, $t7
  				mflo  $t1		#store higher 32 in t1
 		 		multu  $t0, $t7
  				mflo  $t0		#store lower 32 in t0
  				mfhi  $t2
  				add   $t1, $t1, $t2
  				addi  $t8, $t8, -1
  				j pow_loop		#j if power not equal to the number of characters

  				
		dec_x_pow16:
			multu $t0, $t9	#mul lower 32 by power of 16
			mflo $t2		
			mfhi $t4		
			multu $t1, $t9	#mul lower 32 by power of 16
			mflo $t3			#store lower 32 
			addu $t4, $t4, $t3	#add previous hi 32 to current low 32
			addi $s1, $s1, 1         # increment $s1 by one, to point to the next element in the array
		
		int_add:
			beq $s0, 1, other
			addu $s5, $s5, $t2	#final sum add lower 32 to lower 32 of sum
			addu $s6, $s6, $t4	#final sum add higher 32 to higher 32 of sum
			add $s1, $s1, 1
			bne $s0, 1, hex_power	#if count is not 1 then go back to calculate other char
			other:
			addu $s5, $s5, $t9	#add integer from array if count is 1 
			
	jr $ra		#after adding to sum go back to continue main loop
				
				
#multiply that by 16 to the power of the number of $s0 -1  
#-1 from $s0
#


#if string is a valid string branch to sub program 1
#
#It converts a single hexadecimal string to a decimal integer. 
#It must call Subprogram 1 to get the decimal value of each of the characters in the string. 
#Registers must be used to pass parameters into the subprogram. Values must be returned via the stack.
	set_s7_1:
		li $s7,1
	j continue
	
			
subprogram_3:
beqz  $s6, b1	#if upper is zero print lower
move $a0, $s6 #hi address of decimal
li $v0,1	#print integer
syscall
move $a0, $s5 #lo address of decimal
li $v0,1	#print integer
syscall
j functions
b1:
move $a0, $s5 # address of decimal
li $v0,1	#print integer
syscall
j functions
	#la $a0,stack #load from stack into argument for integer output
	#li $v0,1	#print integer
	#syscall
	#li $v0, 10	#exit
	#syscall
	
#displays unsigned decimal integer stack is used to pass parameters into subprogram

tooLarge:
	la $a0, string_tooLarge 
	li $v0,4	#print too large
	syscall
	j functions

Not_a_num:
	la $a0, string_NaN 
	li $v0,4	#print NaN
	syscall
	j calc_dec

Comma:
	la $a0, string_comma 
	li $v0,4	#print NaN
	syscall
	j functions
